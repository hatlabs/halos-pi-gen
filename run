#!/usr/bin/env bash
#
# usage: ./run command [argument ...]
#
# Commands used during development / CI.
# Also, executable documentation for project dev practices.
#
# See https://death.andgravity.com/run-sh
# for an explanation of how it works and why it's useful.

# First, set up the environment.
# (Check the notes at the end when changing this.)

set -o nounset
set -o pipefail
set -o errexit

# Enable this to echo commands as they are executed.
#set -o xtrace

# Change the current directory to the project root.
PROJECT_ROOT=${0%/*}
if [[ $0 != $PROJECT_ROOT && $PROJECT_ROOT != "" ]]; then
  cd "$PROJECT_ROOT"
fi
readonly PROJECT_ROOT=$(pwd)

################################################################################
# Build Commands

function docker:build-all {
  #@ Build all images in the matrix
  #@ Category: Build
  echo "ðŸ—ï¸ Building all images in the matrix..."

  _require act docker gh

  # Clean up any existing pigen_work containers first
  docker:clean

  _run_act

  echo "âœ… All builds completed successfully"
}

function docker:build {
  #@ Build a specific image by job name
  #@ Category: Build

  _require act docker gh yq

  if [ $# -lt 1 ]; then
    echo "âŒ Error: Job name required" >&2
    echo "" >&2
    echo "Usage: ./run docker:build <job-name> [additional act options]" >&2
    echo "" >&2
    echo "Available jobs:" >&2
    _list_jobs >&2
    return 1
  fi

  local job_name="$1"
  shift

  echo "ðŸ—ï¸ Building image: $job_name..."

  # Clean up any existing pigen_work containers first
  docker:clean

  _run_act --matrix "name:$job_name" "$@"

  echo "âœ… Build completed successfully"
}

function docker:clean {
  #@ Remove pigen_work containers
  #@ Category: Utilities

  _require docker

  local containers
  containers=$(docker ps -a --filter "name=pigen_work" --format "{{.Names}}" 2>/dev/null || true)

  if [ -n "$containers" ]; then
    echo "ðŸ§¹ Cleaning up pigen_work containers..."
    # shellcheck disable=SC2086
    docker rm -v $containers 2>/dev/null || true
    echo "âœ… Cleanup completed"
  else
    echo "â„¹ï¸ No pigen_work containers to clean"
  fi
}

################################################################################
# Version Commands

function bumpversion {
  #@ Set version to today's date and commit
  #@ Category: Version
  local today new_version current
  today=$(date +%Y-%m-%d)
  current=$(cat VERSION 2>/dev/null || echo "")
  if [[ "$current" == "$today" ]]; then
    new_version="${today}.2"
  elif [[ "$current" =~ ^${today}\.([0-9]+)$ ]]; then
    new_version="${today}.$(( ${BASH_REMATCH[1]} + 1 ))"
  else
    new_version="$today"
  fi
  echo "$new_version" > VERSION
  git add VERSION
  git commit -m "chore: bump version to ${new_version}"
  echo "Version bumped to ${new_version}"
}

################################################################################
# Help System

function help {
  #@ Show this help message
  #@ Category: Core
  echo "Available commands:"
  echo ""

  # Extract function definitions and their help comments
  awk '/^function / {
    fname = $2
    sub(/[({].*/, "", fname)
    getline
    if ($0 ~ /#@/) {
      desc = $0
      sub(/.*#@ /, "", desc)
      sub(/ *$/, "", desc)
      getline
      if ($0 ~ /#@ Category:/) {
        cat = $0
        sub(/.*Category: /, "", cat)
        sub(/ *$/, "", cat)
        if (!seen[cat]++) categories[++cat_count] = cat
        commands[cat, ++cmd_count[cat]] = fname
        descriptions[cat, cmd_count[cat]] = desc
      }
    }
  }
  END {
    for (i = 1; i <= cat_count; i++) {
      cat = categories[i]
      print "\n" cat ":"
      for (j = 1; j <= cmd_count[cat]; j++) {
        printf "  %-30s %s\n", commands[cat, j], descriptions[cat, j]
      }
    }
  }' "$0"

  echo ""
  echo "Usage: ./run <command> [arguments...]"
}

################################################################################
# Internal Utilities

function _run_act {
  # Run act with common configuration
  # Usage: _run_act [--matrix "name:value"] [additional options...]

  act \
    push \
    -s GITHUB_TOKEN="$(gh auth token)" \
    -P ubuntu-latest-arm64=catthehacker/ubuntu:act-latest \
    --artifact-server-path "$PWD/artifacts" \
    "$@"
}

function _require {
  # Check if required commands are available
  # Usage: _require <command> [command...]

  for cmd in "$@"; do
    if ! command -v "$cmd" &>/dev/null; then
      echo "âŒ Error: required command '$cmd' not found" >&2
      return 1
    fi
  done
}

function _list_jobs {
  # List available job names from workflow file
  # Extracts matrix.include[].name from .github/workflows/main.yml

  local workflow=".github/workflows/main.yml"

  if [ ! -f "$workflow" ]; then
    echo "  (workflow file not found)" >&2
    return 1
  fi

  yq eval '.jobs.image-builder.strategy.matrix.include[].name' "$workflow" 2>/dev/null | while read -r job; do
    echo "  - $job"
  done
}

################################################################################
# Commands end.

# Dispatch to command. A simpler version would be just "$@" (with the quotes!).

TIMEFORMAT=$'\nTask completed in %3lR'
time "${@:-help}"

# Some dev notes for this script.
#
# The commands *require*:
#
# * The current working directory is the project root.
# * The shell options and globals are set as they are.
#
# Inspired by the following:
#  - https://death.andgravity.com/run-sh
#  - http://www.oilshell.org/blog/2020/02/good-parts-sketch.html
#  - https://www.youtube.com/watch?v=SdmYd5hJISM&t=7s
