#!/usr/bin/env bash
#
# usage: ./run command [argument ...]
#
# Commands used during development / CI.
# Also, executable documentation for project dev practices.
#
# See https://death.andgravity.com/run-sh
# for an explanation of how it works and why it's useful.

# First, set up the environment.
# (Check the notes at the end when changing this.)

set -o nounset
set -o pipefail
set -o errexit

# Enable this to echo commands as they are executed.
#set -o xtrace

# Change the current directory to the project root.
PROJECT_ROOT=${0%/*}
if [[ $0 != $PROJECT_ROOT && $PROJECT_ROOT != "" ]]; then
  cd "$PROJECT_ROOT"
fi
readonly PROJECT_ROOT=$(pwd)

################################################################################
# Build Commands

function docker:build-all {
  #@ Build all images in the matrix
  #@ Category: Build
  echo "ðŸ—ï¸ Building all images in the matrix..."

  _require act docker gh

  # Clean up any existing pigen_work containers first
  docker:clean

  _run_act

  echo "âœ… All builds completed successfully"
}

function docker:build {
  #@ Build a specific image by job name
  #@ Category: Build

  _require act docker gh yq

  if [ $# -lt 1 ]; then
    echo "âŒ Error: Job name required" >&2
    echo "" >&2
    echo "Usage: ./run docker:build <job-name> [additional act options]" >&2
    echo "" >&2
    echo "Available jobs:" >&2
    _list_jobs >&2
    return 1
  fi

  local job_name="$1"
  shift

  echo "ðŸ—ï¸ Building image: $job_name..."

  # Clean up any existing pigen_work containers first
  docker:clean

  _run_act --matrix "name:$job_name" "$@"

  echo "âœ… Build completed successfully"
}

function docker:clean {
  #@ Remove pigen_work containers
  #@ Category: Utilities

  _require docker

  local containers
  containers=$(docker ps -a --filter "name=pigen_work" --format "{{.Names}}" 2>/dev/null || true)

  if [ -n "$containers" ]; then
    echo "ðŸ§¹ Cleaning up pigen_work containers..."
    # shellcheck disable=SC2086
    docker rm -v $containers 2>/dev/null || true
    echo "âœ… Cleanup completed"
  else
    echo "â„¹ï¸ No pigen_work containers to clean"
  fi
}

function docker:build-local {
  #@ Build a specific image directly with pi-gen (no act)
  #@ Category: Build

  _require docker git

  if [ $# -lt 1 ]; then
    echo "Error: config file required" >&2
    echo "" >&2
    echo "Usage: ./run docker:build-local <config-file>" >&2
    echo "" >&2
    echo "Available configs:" >&2
    for f in config.*; do
      [ -f "$f" ] && echo "  $f"
    done >&2
    return 1
  fi

  local config_file="$1"
  if [ ! -f "$config_file" ]; then
    echo "Error: config file '$config_file' not found" >&2
    return 1
  fi

  local pi_gen_dir="pi-gen"

  # Clone pi-gen if not present
  if [ ! -d "$pi_gen_dir" ]; then
    echo "Cloning pi-gen (arm64 branch)..."
    git clone --depth 1 --branch arm64 https://github.com/RPi-Distro/pi-gen.git "$pi_gen_dir"
  fi

  # Copy stages, config, and VERSION into pi-gen
  echo "Preparing build..."
  cp VERSION "$pi_gen_dir/VERSION"
  cp -R stage-* "$pi_gen_dir/"
  touch "$pi_gen_dir/stage5/SKIP"
  touch "$pi_gen_dir/stage2/SKIP_IMAGES"
  touch "$pi_gen_dir/stage4/SKIP_IMAGES"
  cp "$config_file" "$pi_gen_dir/config"

  local halos_version
  halos_version=$(cat VERSION)
  local img_name
  img_name=$(grep '^IMG_NAME=' "$config_file" | head -1 | cut -d'"' -f2)
  local img_filename="${img_name}_${halos_version}"

  echo "Building $img_name (version $halos_version)..."
  cd "$pi_gen_dir"
  RELEASE='trixie' IMG_FILENAME="$img_filename" ARCHIVE_FILENAME="$img_filename" ./build-docker.sh
  cd "$PROJECT_ROOT"

  echo "Build complete. Output in $pi_gen_dir/deploy/"
}

################################################################################
# Flash Commands

function flash-remote {
  #@ Flash an image to a remote device over the network
  #@ Category: Flash

  if [ $# -lt 2 ]; then
    echo "Usage: ./run flash-remote <host> <image>" >&2
    echo "" >&2
    echo "Examples:" >&2
    echo "  ./run flash-remote halos.local pi-gen/deploy/image.img.xz" >&2
    echo "  ./run flash-remote halos.local image.img" >&2
    return 1
  fi

  local host="$1"
  local image="$2"
  local data_port=9999
  local signal_port=9998

  # Validate image file exists
  if [ ! -f "$image" ]; then
    echo "Error: image file not found: $image" >&2
    return 1
  fi

  # Determine decompression command
  local decompress_cmd
  case "$image" in
    *.img.xz) decompress_cmd="xzcat" ;;
    *.img.gz) decompress_cmd="zcat" ;;
    *.img)    decompress_cmd="cat" ;;
    *)
      echo "Error: unsupported image format (expected .img, .img.xz, or .img.gz)" >&2
      return 1
      ;;
  esac

  _require ssh ncat "$decompress_cmd"

  echo "=== Phase 0: Resolving hostname and checking target ==="

  # Verify busybox is available on target
  if ! ssh -n "$host" "command -v busybox" >/dev/null 2>&1; then
    echo "Error: busybox not found on $host (required for flash helper)" >&2
    return 1
  fi

  local target_ip
  target_ip=$(ssh -n "$host" "hostname -I | awk '{print \$1}'")
  if [ -z "$target_ip" ]; then
    echo "Error: could not resolve IP for $host" >&2
    return 1
  fi
  echo "Resolved $host -> $target_ip"

  echo ""
  echo "=== Phase 1: Preparing target ==="

  # Detect root block device using lsblk PKNAME (parent kernel name)
  local root_part root_dev
  root_part=$(ssh -n "$host" "findmnt -no SOURCE /")
  if [ -z "$root_part" ]; then
    echo "Error: could not detect root partition" >&2
    return 1
  fi

  root_dev=$(ssh -n "$host" "lsblk -ndo PKNAME '$root_part'")
  if [ -z "$root_dev" ]; then
    echo "Error: could not determine parent device for $root_part" >&2
    return 1
  fi
  root_dev="/dev/$root_dev"

  # Validate the device exists
  if ! ssh -n "$host" "test -b '$root_dev'"; then
    echo "Error: $root_dev is not a valid block device on $host" >&2
    return 1
  fi

  local dev_size
  dev_size=$(ssh -n "$host" "lsblk -bno SIZE '$root_dev' | head -1")
  local dev_size_gb
  dev_size_gb=$((dev_size / 1073741824))

  local image_size
  image_size=$(stat -f%z "$image" 2>/dev/null || stat -c%s "$image" 2>/dev/null || true)
  if [ -z "$image_size" ]; then
    echo "Error: could not determine image file size" >&2
    return 1
  fi
  local image_size_mb
  image_size_mb=$((image_size / 1048576))

  local size_label="on-disk"
  if [[ "$image" == *.img.xz ]] || [[ "$image" == *.img.gz ]]; then
    size_label="compressed"
  fi

  echo ""
  echo "  Target device: $root_dev (~${dev_size_gb} GB)"
  echo "  Root partition: $root_part"
  echo "  Image file: $image (${image_size_mb} MB ${size_label})"
  echo "  Target host: $host ($target_ip)"
  echo ""
  echo "WARNING: This will ERASE ALL DATA on $root_dev on $host."
  echo "The device will be unreachable during flashing and will reboot when done."
  echo ""
  read -r -p "Type 'yes' to proceed: " confirm
  if [ "$confirm" != "yes" ]; then
    echo "Aborted."
    return 1
  fi

  echo ""
  echo "Copying flash helper to target..."

  # Helper script flow:
  #   1. Stop services
  #   2. Handshake with client on signal port (safe to abort here)
  #   3. Start busybox nc | dd listener on data port
  #   4. dd writes to raw block device (bypasses mounted filesystem)
  #   5. After transfer: sync, reboot -f
  ssh "$host" "cat > /dev/shm/flash-helper.sh" <<'HELPER_EOF'
#!/bin/bash
set -eo pipefail

TARGET_DEV="$1"
DATA_PORT="$2"
SIGNAL_PORT="$3"

echo "flash-helper: starting (target=$TARGET_DEV, data=$DATA_PORT, signal=$SIGNAL_PORT)"

# Stop services
echo "flash-helper: stopping services..."
systemctl stop 'container-*' 'marine-*' 'halos-*' cockpit docker 2>/dev/null || true
sync

# --- Handshake: signal readiness and wait for client confirmation ---
# This happens BEFORE any destructive action so the device can recover if the client aborts.
echo "flash-helper: signaling ready on port $SIGNAL_PORT..."
REPLY=$(echo "READY" | busybox nc -l -p "$SIGNAL_PORT" -w 60)
if [ "$REPLY" != "GO" ]; then
  echo "flash-helper: client did not confirm (got '$REPLY'), aborting"
  echo "flash-helper: rebooting to restore services..."
  reboot
  exit 1
fi
echo "flash-helper: client confirmed, starting listener"

# --- Start nc|dd listener and wait for transfer ---
echo "flash-helper: starting nc|dd listener on port $DATA_PORT -> $TARGET_DEV"
busybox nc -l -p "$DATA_PORT" | dd of="$TARGET_DEV" bs=4M 2>/dev/shm/dd-status
echo "flash-helper: dd complete, status:"
cat /dev/shm/dd-status 2>/dev/null || true
sync

echo "flash-helper: rebooting..."
reboot -f
HELPER_EOF

  ssh -n "$host" "chmod +x /dev/shm/flash-helper.sh"

  echo "Launching flash helper on target..."
  # Use setsid to fully detach from SSH session, preventing SIGHUP on disconnect
  ssh -n "$host" "sudo setsid /dev/shm/flash-helper.sh '$root_dev' '$data_port' '$signal_port' </dev/null >/dev/shm/flash-helper.log 2>&1 &"

  echo ""
  echo "=== Phase 2: Streaming image ==="

  # Handshake: wait for helper to signal readiness on signal port
  echo "Waiting for target to be ready..."
  local retries=0
  local max_retries=30
  while true; do
    local reply
    reply=$(echo "GO" | ncat "$target_ip" "$signal_port" 2>/dev/null) || true
    if [ "$reply" = "READY" ]; then
      echo "Target is ready, confirmed handshake."
      break
    fi
    retries=$((retries + 1))
    if [ "$retries" -ge "$max_retries" ]; then
      echo "Error: target not ready after ${max_retries}s" >&2
      echo "The device should still be recoverable (no destructive action was taken)." >&2
      return 1
    fi
    sleep 1
    printf "."
  done

  # The data port listener starts immediately after the handshake completes.
  # Give it a moment to bind before connecting.
  sleep 2

  local start_time
  start_time=$(date +%s)

  echo "Streaming image..."
  if ! "$decompress_cmd" "$image" | ncat --send-only "$target_ip" "$data_port"; then
    echo "" >&2
    echo "Error: transfer failed." >&2
    echo "The device may have a partial image. It will attempt to sync and reboot." >&2
    echo "If it doesn't come back, manual re-flash is needed." >&2
    return 1
  fi

  local end_time elapsed_s
  end_time=$(date +%s)
  elapsed_s=$((end_time - start_time))

  echo ""
  echo "Image transfer complete (${elapsed_s}s)."
  echo "The device is syncing and will reboot automatically."
  echo ""
  echo "Wait ~60s then try: ssh $host"
}

################################################################################
# Version Commands

function bumpversion {
  #@ Set version to today's date and commit
  #@ Category: Version
  local today new_version current
  today=$(date +%Y-%m-%d)
  current=$(cat VERSION 2>/dev/null || echo "")
  if [[ "$current" =~ ^${today}\.([0-9]+)$ ]]; then
    new_version="${today}.$(( ${BASH_REMATCH[1]} + 1 ))"
  else
    new_version="${today}.0"
  fi
  echo "$new_version" > VERSION
  git add VERSION
  git commit -m "chore: bump version to ${new_version}"
  echo "Version bumped to ${new_version}"
}

################################################################################
# Help System

function help {
  #@ Show this help message
  #@ Category: Core
  echo "Available commands:"
  echo ""

  # Extract function definitions and their help comments
  awk '/^function / {
    fname = $2
    sub(/[({].*/, "", fname)
    getline
    if ($0 ~ /#@/) {
      desc = $0
      sub(/.*#@ /, "", desc)
      sub(/ *$/, "", desc)
      getline
      if ($0 ~ /#@ Category:/) {
        cat = $0
        sub(/.*Category: /, "", cat)
        sub(/ *$/, "", cat)
        if (!seen[cat]++) categories[++cat_count] = cat
        commands[cat, ++cmd_count[cat]] = fname
        descriptions[cat, cmd_count[cat]] = desc
      }
    }
  }
  END {
    for (i = 1; i <= cat_count; i++) {
      cat = categories[i]
      print "\n" cat ":"
      for (j = 1; j <= cmd_count[cat]; j++) {
        printf "  %-30s %s\n", commands[cat, j], descriptions[cat, j]
      }
    }
  }' "$0"

  echo ""
  echo "Usage: ./run <command> [arguments...]"
}

################################################################################
# Internal Utilities

function _run_act {
  # Run act with common configuration
  # Usage: _run_act [--matrix "name:value"] [additional options...]

  act \
    push \
    -s GITHUB_TOKEN="$(gh auth token)" \
    -P ubuntu-latest-arm64=catthehacker/ubuntu:act-latest \
    --artifact-server-path "$PWD/artifacts" \
    "$@"
}

function _require {
  # Check if required commands are available
  # Usage: _require <command> [command...]

  for cmd in "$@"; do
    if ! command -v "$cmd" &>/dev/null; then
      echo "âŒ Error: required command '$cmd' not found" >&2
      return 1
    fi
  done
}

function _list_jobs {
  # List available job names from workflow file
  # Extracts matrix.include[].name from .github/workflows/main.yml

  local workflow=".github/workflows/main.yml"

  if [ ! -f "$workflow" ]; then
    echo "  (workflow file not found)" >&2
    return 1
  fi

  yq eval '.jobs.image-builder.strategy.matrix.include[].name' "$workflow" 2>/dev/null | while read -r job; do
    echo "  - $job"
  done
}

################################################################################
# Commands end.

# Dispatch to command. A simpler version would be just "$@" (with the quotes!).

TIMEFORMAT=$'\nTask completed in %3lR'
time "${@:-help}"

# Some dev notes for this script.
#
# The commands *require*:
#
# * The current working directory is the project root.
# * The shell options and globals are set as they are.
#
# Inspired by the following:
#  - https://death.andgravity.com/run-sh
#  - http://www.oilshell.org/blog/2020/02/good-parts-sketch.html
#  - https://www.youtube.com/watch?v=SdmYd5hJISM&t=7s
